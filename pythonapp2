#!/usr/bin/env python

from flask import Flask, request, render_template, session, url_for, redirect, make_response
from datetime import datetime
from elasticsearch import *
from elasticsearch_dsl import *
from collections import defaultdict
import json
import redis

import json


es = Elasticsearch()

# create my flask application
app = Flask(__name__)

# connecting to redis server
r = redis.StrictRedis(host='127.0.0.1', port=6379, db=0)

# setiing the secret key
app.secret_key = 'rohitjoseph0808@gmail.com'


def get_id():  # from cookie
    return request.cookies.get("name")

def get_fields(): #from userId (via redis)
    username=request.cookies.get("name")
    a=r.smembers(username)
    a=list(a)
    return a

def add_filter(field,value):
    username=request.cookies.get("name")
    session=username+'session'
    fv=str(field)+'+'+str(value)
    a=r.sadd(session,fv)

def remove_filter(field,value):
    username=request.cookies.get("name")
    session=username+'session'
    fv=str(field)+'+'+str(value)
    a=r.srem(session,fv)
def get_filter(fieldName): #from sessionId (via redis)
    username=request.cookies.get("name")
    session=username+'session'
    a=r.smembers(session)
    a=list(a)
    dis = defaultdict(list)
    for cur in a:
        kvpair = cur.split('+')
        dis[kvpair[0]].append(kvpair[1])
    if fieldName in dis:
        del dis[fieldName]
    dis["userId"].append(get_id())
    print dis
    return dis


def funquery(fieldName,endtime,starttime):
    finalquery = dict()

    query = dict()

    bool = dict()
    must = []
    print get_filter(fieldName)
    for key,value in get_filter(fieldName).iteritems():
        bools={}
        should=[]
        for values in value:
            should.append({"term": {key: values}})
        bools["should"]=should
        must.append({"bool":bools})

    bool["must"] = must

    timestamp = dict()
    timestamp["gte"] = starttime
    timestamp["lte"] = endtime

    range = {"timestamp": timestamp}
    filter = {"range": range}
    bool["filter"] = filter

    query["bool"] = bool

    finalquery["query"] = query

    field = {"field": fieldName}
    terms = {"terms": field}
    fieldagg = {"fieldagg": terms}

    finalquery["aggs"] = fieldagg
    return finalquery

def jsonResponse(fieldName,buckets):
    jsonList = []
    jsonList.append({"field": fieldName})

    for _pair in buckets:
        a = dict()
        a["key"] = _pair["key"]
        a["doc_count"] = _pair["doc_count"]
        jsonList.append(a)
    return jsonList


@app.route("/login", methods=['GET', 'POST'])
@app.route("/", methods=['GET', 'POST'])
def login():
    if request.method == 'GET':
        msg = False
        return render_template('login.html', message=msg)

    if request.method == 'POST':

        u = request.form['username']
        p = request.form['password']

        if u == 'admin' and p == 'admin':
            response = make_response(redirect('/query'))
            response.set_cookie('name', u)
            return response

        else:
            msg = True
            return render_template('login.html', message=msg)

# Insert the GET parameters
@app.route('/insert', methods=['GET'])
def default():
    params = request.args.items()
    toInsert = dict()
    msg = True
    username = request.cookies.get("name")

    # testing for correct input from client side
    for cur in params:
        if cur[0] == "" or cur[1] == "":
            return render_template('400.html', message=msg)

    # insert in redis set
    for cur in params:
        a = r.sadd(username, cur[0])

    for cur in params:
        toInsert[cur[0]] = cur[1]

    # add user id
    print get_id()
    toInsert["userId"] = get_id()
    # add Timestamp
    toInsert["timestamp"] = (datetime.now().isoformat().split('.'))[0]

    res = es.index(index="app", doc_type='users', body=json.dumps(toInsert))

    # to create
    if res['created'] == True:
        return render_template('register.html', message=msg)
    else:
        return render_template('500.html', message=msg)


# query GET
@app.route('/query', methods=['GET'])
def query_page():
    finalFields = get_fields()
    params = request.args.items()
    params.sort()
    print params
    if(len(params)==0):
        # todo: add 400 for empty cookie
        return render_template('fields.html', fields=get_fields())
    else:
        s = Search().using(es)

        #remove_filter('rr', '5')
        if(len(params)==4):
            add_filter(params[1][1],params[3][1])

        query = funquery(params[1][1],params[0][1],params[2][1])
        print json.dumps(query)
        s.update_from_dict(query).to_dict()
        response = s.execute()
        jsonList=jsonResponse(params[1][1], response.aggregations.fieldagg.buckets)
        print json.dumps(jsonList)
        return json.dumps(jsonList)


# Delete the filter
@app.route('/query', methods=['DELETE'])
def delete():
    params = request.args.items()
    params.sort()
    print params
    s = Search().using(es)

    if (len(params) == 4):
        remove_filter(params[1][1], params[3][1])

    query = funquery(params[1][1], params[0][1], params[2][1])
    print query
    print "DEL"
    s.update_from_dict(query).to_dict()
    response = s.execute()
    jsonList = jsonResponse(params[1][1], response.aggregations.fieldagg.buckets)
    print jsonList
    return json.dumps(jsonList)


if __name__ == '__main__':
    app.run(host='172.16.169.33', port=5000, debug=True, use_reloader=True)
